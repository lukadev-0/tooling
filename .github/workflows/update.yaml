name: Update tools

on:
  workflow_dispatch:
  schedule:
    # Run every day at 18:30 UTC
    - cron: '30 18 * * *'

concurrency:
  # Ensure this workflow does not run twice at the same time
  group: ${{ github.workflow }}

jobs:
  fetch-new-versions:
    name: Fetch new versions
    runs-on: ubuntu-latest

    outputs:
      new_versions: ${{ steps.new_versions.outputs.new_versions }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup pesde
        uses: axiom-co/setup-pesde@b690699ace34169731b6b2a1c93b2008472038a7
        with:
          cache: true
      - name: Install dependencies
        run: pesde install --locked
      - name: Fetch new versions
        id: new_versions
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          lune -V
          new_versions="$(lune run update_tools -- --json | jq -c 'to_entries | map({ package: .key, versions: .value })')"
          echo "new_versions=$new_versions" >> "$GITHUB_OUTPUT"

  update-package:
    name: Update ${{ matrix.package }}
    runs-on: ubuntu-latest

    needs: fetch-new-versions
    if: needs.fetch-new-versions.outputs.new_versions != '[]'
    strategy:
      matrix:
        include: ${{ fromJSON(needs.fetch-new-versions.outputs.new_versions) }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup pesde
        uses: axiom-co/setup-pesde@b690699ace34169731b6b2a1c93b2008472038a7
        with:
          cache: true
      - name: Install dependencies
        run: pesde install --locked
      - name: Update package
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"

          # List all branches that start with `update/`
          branches="$(git ls-remote --heads origin 'update/*' | awk '{print $2}')"

          # Switch to latest branch, create it if it doesn't exist
          latest_branch="update/${{ matrix.package }}/latest"
          if echo "$branches" | grep -Fxq "refs/heads/$latest_branch"; then
            git fetch --depth=1 origin "$latest_branch"
            git switch "$latest_branch"
          else
            git switch -c "$latest_branch"
          fi

          echo '${{ toJson(matrix.versions) }}' | jq -r '.[]' | while read -r version; do
            branch="update/${{ matrix.package }}/$version"
            
            # Skip if there is already a branch for this version
            if echo "$branches" | grep -Fxq "refs/heads/$branch"; then
              echo "'$branch' already exists, skipping..."
              continue
            fi

            # Switch to new branch
            git switch -c "$branch"

            # Perform the update
            lune run update_tools -- "${{ matrix.package }}" "$version"

            # Stage & commit changes
            git add .
            git commit -m "${{ matrix.package }}: $version"

            # Push
            git push origin "$branch"

            # Create pull request
            gh pr create \
              --fill \
              --body-file - \
          <<EOF
          This is an autogenerated PR that updates \`${{ matrix.package }}\` to **$version**.
          EOF

            # Update the latest branch
            git branch -f "$latest_branch"
          done

          git push --force origin "$latest_branch"
